/*!
 * @page glossary Glossary
 *
 *
 * @section asset_management_system Asset Management System
 *
 * Responsible for managing @ref entity "Entities", in some structured
 * fashion.  Often based around some kind of a database. Many asset
 * management systems allow entities to be 'versioned', or related to
 * each other.  The primary goal being make collaborative working
 * easier, and to allow the history of work to be tracked. Very similar
 * to source control within a software development environment.
 *
 *
 * @section Context Context
 *
 * A Context is an object that holds all of the persistent state between
 * a set of connected calls to the API. Its properties define details of
 * how a @ref host is calling the Asset API. In addition to information
 * about the desired access (read/write) and persistence of data, the
 * context's @ref locale may contain information to better define which
 * part of the users workflow the call is being generated by.
 *
 * The information in the context is vital to interpreting the intent of
 * a @ref host "hosts" actions. For example, if an Image @ref
 * Specification is passed to a browser, a context access of 'kWrite'
 * indicates the host wishes browse for a destination to publish a
 * single image @ref entity to, so any viable container should be
 * selectable. If it is 'kRead' then the host is wishing to browse for
 * an entity to read, so only existing entities that match the
 * specification should be presented. If 'kWriteMultiple' is specified,
 * then the applicable selections generally changes again.
 *
 * The Context also holds an opaque (to the host) data pointer, created
 * by the @ref ManagerInterface, that contains any persistent state its
 * implementation wishes to store.
 *
 * @see @fqref{Context} "Context"
 *
 * @section DCC Digital Contentent Creation tool (DCC)
 *
 * Within the Media and Entertainment industry (and possibly further
 * afield), Digital Content Creation tools refer to the applications
 * used to produce graphics, audio and other artistic works. For
 * example, Adobe Photoshop, Autodesk Maya, and Foundry's Nuke.
 *
 *
 * @section entity entity
 *
 * An 'entity' is the generic name for something that is managed by a
 * @ref asset_management_system. Entities are identified by an @ref
 * entity_reference. We choose the term 'entity' as some systems
 * give a specific meaning to an 'asset', such that all assets are
 * entities, but not all entities are assets.
 *
 * As a simplified example, an 'asset' may always require to exist in
 * some organizational hierarchy, and be the only thing that can be
 * version managed. An entity however, can refer to anything that the
 * Asset Management System knows about, including a part of the
 * organizational hierarchy, or a specific version or component part of
 * an 'asset'.
 *
 * In the core API, entities hold data for one or more @ref trait "traits".
 * Traits have an id, and zero or more properties holding simple value
 * types.
 *
 * This makes it relatively straightforward for an @ref
 * asset_management_system to provide support for any entity that a @ref
 * host may wish to store, by simply storing and retrieving these three
 * properties from its persistent store. If it wishes, or understands
 * specific entity traits, it can always provide more sophisticated
 * mappings to its own internal types, to provide a better user
 * experience.
 *
 *
 * @section entity_reference Entity Reference
 *
 * An 'entity reference' is the currency of the core API layer. It is
 * used to identify an @ref entity within an @ref asset_management_system
 * and is defined as follows:
 *
 * > A <a href="http://en.wikipedia.org/wiki/Uniform_resource_identifier"
 * > target="_blank">Uniform Resource Identifier</a> that points to a single,
 * > discreet @ref entity in an @ref asset_management_system. If the entity
 * > identified by the reference exists as a child in a hierarchy, then the
 * > entity reference must identify a specific path to that entity, so that
 * > it has a single immediate parent.
 *
 * It is deliberately **not** referred to as an 'id', and should not be
 * thought of as being analogous to a primary key in a database of
 * entities, for various reasons detailed below.
 *
 * An entity reference can be any string, and there are no constraints
 * on the content of the reference other than that of a std::string.
 * It's worth noting however, that if no custom UI widgets are supplied
 * by a manager, a @ref host will simply display it as a standard
 * string. It is up to the design of the @ref manager to decide on the
 * format for it's entity references, and whether they are in a human
 * readable form.
 *
 * > Note: We strongly recommend using a human-readable form that
 * > follows <a
 * href=https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#cite_ref-FOOTNOTERFC_3986,_section_32005_23-0"
 * target="_blank">RFC_3986</a>.
 *
 * The following are examples of perfectly valid entity references:
 *
 *  @li `myasset://DVR/ep01/build/prop/table?v=6&t=model&f=alembic`
 *  @li `e1d2e41c-9594-11e2-9619-f23c91ae2917`
 *  @li <tt>{'job':'DVR', 'path':['ep01','build','prop','table'], 'version':'6', 'type':'model',
 * 'format':'alembic'}</tt>
 *
 * Each of them have their relative merits in different situations, and
 * <b>it is no concern of this set of APIs which one is used</b>. There
 * are only three requirements of the format, and the way it is
 * interpreted by the @ref ManagerInterface "ManagerInterface":
 *
 * 1. Discoverability
 * ------------------
 * It is essential that any given string can be readily identified as
 * being an entity reference or not. The
 * @fqref{hostApi.Manager.isEntityReferenceString}
 * "isEntityReferenceString" method will be called frequently by a @ref
 * host to determine if the arbitrary user input is a reference to a
 * managed entity.
 *
 * 2. Uniform Resource Location
 * ----------------------------
 * In an @ref asset_management_system that permits an entity to only exists
 * in a single place within its hierarchy, the subtle differences between a
 * <a href="http://en.wikipedia.org/wiki/Uniform_resource_locator"
 * target="_blank">URL</a> and a <a
 * href="http://en.wikipedia.org/wiki/Uniform_resource_name"
 * target="_blank">URN</a> (both being URIs) may not be relevant. Both a
 * 'UUID' style reference such as `"e1d2e41c-9594-11e2-9619-f23c91ae2917"`
 * and an URL such as
 * `"myasset://DVR/ep01/build/prop/table?v=1&t=model&f=alembic"` may both
 * resolve to the same entity.
 *
 * However, if the @ref asset_management_system allows an entity to be
 * 'aliased' within the system (perhaps analogous to a symbolic link in
 * a POSIX file system), then the UUID approach may no longer comply
 * with the 'single immediate parent' constraint of the original
 * entity reference definition. For example, if the same underlying
 * Entity UUID was available through the following paths:
 *
 *  @li `myasset://DVR/ep01/build/prop/table?v=6...`
 *  @li `myasset://library/furniture/table?v=2...`
 *  @li `myasset://TTL/library/prop/cottageTabl?v=1...`
 *
 * The entity reference passed through this API must always uniquely
 * locate the entity via a specific path, such that relationship queries
 * produce the expected results.
 *
 * In such a system, the ManagerInterface may provide access to
 * alternate paths from any one of these path-specific references via
 * the @ref openassetio.managerApi.ManagerInterface.ManagerInterface.getWithRelationship
 * "getWithRelationship" method, with a suitable relationship @ref trait_set.
 *
 * 3. 'Potential' entity representation
 * ------------------------------------
 * It is required within the architecture of this API, to potentially
 * derive an entity reference for new entity **before** it has been
 * created.
 *
 * For example, a 'Save As...' dialog will need to return an entity
 * reference that can be passed to @fqref{hostApi.Manager.register_}
 * "Manager.register()".
 *
 * This does not preclude the use of UUID-style references in some cases
 * if desired, it simply means that the Manager may need to support
 * *multiple* formats for an entity reference. Again, this is entirely
 * up to the manager to decide how it wishes to handle future entities.
 *
 *
 * @section host host
 *
 * A 'host' represents some application or tool that would like to
 * interact with an @ref asset_management_system. This is usually a
 * user-facing Digital Content Creation application or a pipeline
 * tool or script.
 *
 * The purpose of OpenAssetIO is to standardize the interaction between a host
 * and an @ref asset_management_system in order to persis or query data.
 * A host communicates with a @ref manager via the @ref openassetio.hostApi.Manager.Manager class.
 *
 * > Note: The Manager class is an abstraction, that takes care of
 * > sundry housekeeping and helps manage session state. Internally it
 * > holds an instance of the @ref openassetio.managerApi.ManagerInterface.ManagerInterface
 * > "ManagerInterface" implementation supplied by the @ref
 * > asset_management_system.
 *
 * The host itself is made available to a @ref manager "manager's" @ref
 * ManagerInterface via the @ref
 * openassetio.managerApi.HostSession "HostSession" supplied to each API
 * call. This allows the manager to adapt its behavior accordingly (if
 * required), and perform any additional actions it may wish to as part
 * of @ref publish "publishing".
 *
 *
 * @section HostInterface
 *
 * The @fqref{hostApi.HostInterface} "HostInterface" class is the
 * abstract interface that any @ref host must implement in order to
 * initialize the API. It will usually contain logic to map native
 * features of the host into the well-known terms defined by this API.
 *
 * The HostInterface is never used directly by a @ref manager, and is
 * instead accessed through the @ref openassetio.managerApi.Host
 * abstraction, provided by the @ref openassetio.managerApi.HostSession
 * passed to the manager's implementation. This allows assorted
 * house-keeping and auditing to be performed by the API middleware.
 *
 *
 * @section locale locale
 *
 * Within OpenAssetIO, the term "locale" is used to define which part of
 * a @ref host "host's" implementation is making a particular call to
 * the API. A suitably configured @fqref{TraitsData} "TraitsData"
 * instance is supplied through the @fqref{Context.locale}
 * "locale" property of the @fqref{Context} "Context", which is in turn
 * supplied to most @ref ManagerInterface method calls.
 *
 * The locale may be used by a manager to customize its behavior if
 * desired. The locale may contain references to specific objects in the
 * host's native SDK that can be used to determine more information
 * about the origin of the API request.
 *
 * A common use of the locale by a manager is to obtain further
 * information about the originating document during a publish.
 *
 *
 * @section ManagerInterface
 *
 * The @ref openassetio.managerApi.ManagerInterface.ManagerInterface
 * "ManagerInterface" class is the abstract interface that any @ref
 * asset_management_system must implement in order to be used by the
 * API. It will usually contain appropriate logic to map native features
 * of the asset manager into the well-known terms defined by this API.
 *
 * The ManagerInterface is never used directly by a @ref host, and is
 * instead accessed through the @ref openassetio.hostApi.Manager
 * abstraction. This allows assorted house-keeping and state management
 * to be performed by the API middleware.
 *
 *
 * @section PythonPluginSystemManagerPlugin Manager Plugin
 *
 * The Plug-in mechanism implemented by the @ref
 * openassetio.pluginSystem automatically discovers packages that
 * provide an instance of the openassetio.pluginSystem.PythonPluginSystemManagerPlugin
 * using a search-path based mechanism. This is independent of
 * $PYTHONPATH, and presently searches using the environment variable
 * @ref plugin_path_var
 *
 * The PythonPluginSystemManagerPlugin instance is then responsible for
 * constructing an instance of the respective @ref
 * asset_management_system's implementation of the @ref
 * openassetio.managerApi.ManagerInterface "ManagerInterface".
 *
 *
 * @section default_config_var $OPENASSETIO_DEFAULT_CONFIG
 *
 * This is the environment variable used to discover a "default"
 * configuration for an OpenAssetIO session. It defines which manager to
 * use, along with any applicable settings. It should point to a simple
 * TOML config file, see @fqref{hostApi.ManagerFactory.defaultManagerForInterface}
 * "ManagerFactory" for more details of supported options.
 *
 * All OpenAssetIO @ref host "hosts" should support deriving their
 * configuration from this file, to simplify centralized config
 * management.
 *
 *
 * @section plugin_path_var $OPENASSETIO_PLUGIN_PATH
 *
 * This is the environment variable used to discover @ref PythonPluginSystemManagerPlugin
 * "PythonPluginSystemManagerPlugins", it is searched left-to-right,
 * using standard `$PATH` semantics (delimited by `:` on POSIX systems
 * and `;` on Windows). The first package that registers a specific
 * identifier wins.
 *
 * So to override a plug-in with a dev version, ensure it is to the left
 * of the standard plug-in.
 *
 *
 * @section logging_severity_var $OPENASSETIO_LOGGING_SEVERITY
 *
 * This is the environment variable used to control the default logging
 * severity of the API. Note that many @ref host "hosts" re-direct
 * logging to their own system. Usually in these cases, logging severity
 * is then controlled by the host's own configuration mechanism(s).
 *
 *
 * @section manager_state Manager State
 *
 * The @ref ManagerInterface is, by design, a stateless, re-entrant API.
 * Consequently, the result of any call to an instance of this class
 * should solely depend on the methods arguments. In real-world use
 * however, it is often required to understand that a series of discreet
 * calls to the API may be part of the same logical user action.
 *
 * The most common (and extreme) example of this is a distributed
 * render. Where multiple processes, spread across multiple hosts are
 * all part of the same 'task'. Many asset systems support the concept
 * of @ref meta_version "meta-versions" (eg: "vLatest"). Providing
 * stable resolution of these is essential to deterministic renders.
 *
 * A far simpler example of associating API calls is to provide caching
 * relative to the lifetime of a specific action.
 *
 * OpenAssetIO provides a mechanism to support the entire range of use cases
 * for 'session state' whilst keeping the interface itself stateless.
 *
 * This is achieved by allowing the manager to inject state into each
 * @ref Context created by the @ref host. The host guarantees to
 * manage the lifetime of their contexts appropriately, and re-use the
 * same context for logically related API calls. The result of this is
 * that the manager can use injected state object to form a persistent
 * anchor across distributed calls.
 *
 * The manager's state object is opaque to the host.
 *
 *   @see @fqref{managerApi.ManagerInterface.createState} "ManagerInterface.createState"
 *   @see @fqref{managerApi.ManagerInterface.createChildState} "ManagerInterface.createChildState"
 *   @see @fqref{managerApi.ManagerInterface.persistenceTokenForState} "ManagerInterface.persistenceTokenForState"
 *   @see @fqref{managerApi.ManagerInterface.stateFromPersistenceToken} "ManagerInterface.stateFromPersistenceToken"
 *
 *
 * @section meta_version Meta-version
 *
 * It is common for am @ref asset_management_system to allow an @ref entity
 * version managed. Some systems also allow the concept of what we call a
 * 'meta-version'. For example "latest" or "latestApprovedForLighting".  These
 * are version strings that need to be further resolved using @ref
 * openassetio.hostApi.Manager.Manager.finalizedEntityVersion
 * "finalizedEntityVersion()" before they can be assumed to be
 * pointing to a specific 'concrete' version of an entity.
 *
 * Stable resolution of meta-versions over time, or across a
 * distributed task is achieved via the @ref manager_state mechanism.
 *
 *
 * @section manager manager
 *
 * A 'manager' represents some @ref asset_management_system that forms
 * a source of truth for some number of entities. They usually consist
 * of some centralized database that tracks assets - known here as @ref
 * entity "entities", managing their versions and relationships.
 *
 * The purpose of OpenAssetIO is to standardize the interactions between a @ref
 * host and one of these systems in order to query or persist data.
 *
 * Asset managers will generally re-map the well-known OpenAssetIO
 * concepts (eg @ref trait "traits" and their properties into their own
 * internal structures, and back again when queried.
 *
 * Managers are made available via a @ref
 * PythonPluginSystemManagerPlugin, that ultimately registers classes
 * derived from the @ref ManagerInterface.
 *
 * A @ref host never uses the ManagerInterface class directly, but instead
 * uses the @ref openassetio.hostApi.Manager "Manager" class. This
 * indirection allows sundry house keeping and state management.
 *
 *
 * @section preflight preflight
 *
 * @ref asset_management_system "Asset management systems" are roughly
 * divided into two camps - those that can tell a @ref host in advance
 * the location at which data should be created, and those that simply
 * track data at its existing location. A @ref manager implementation
 * declares its behavior to the host via the
 * @fqref{hostApi.Manager.managementPolicy} "managementPolicy" method.
 *
 * If a manager has said it is capable of resolving future entities
 * ahead of time, the host must call the
 * @fqref{hostApi.Manager.preflight} "preflight" method and resolve the
 * returned @ref entity_reference to determine the manager's chosen
 * location for the data and use this for any write operations.
 *
 * The `preflight` method is also allowed to change the entity
 * reference as required. This mechanism serves several purposes:
 *
 * - It allows the manager to dictate if an existing target entity is
 *   mutable. It can return an updated entity reference if the
 *   original entity should be left untouched (ie. creating a new
 *   version).
 * - It allows the manager to allocate a placeholder version for a
 *   reference containing a @ref meta_version "meta-version".
 * - If appropriate, it can avoid the need to retrospectively copy data
 *   to its intended destination immediately after creation.
 *
 * There are two scenarios where `preflight` will not be called:
 *
 * - When the manager has declared that it is not capable of providing
 *   trait properties in advance of an entity being created (via
 *   @fqref{hostApi.Manager.managementPolicy} "managementPolicy").
 * - When the data already exists at some target location, such as when
 *   assetizing an existing file.
 *
 * In these situations, only @ref register will be called by the host.
 * In the first situation, calling `preflight` would be pointless
 * as the manager has no way to provide a meaningful answer.
 *
 * In the second situation it removes the responsibility for the host to
 * transfer the data from its current location to that specified by
 * `preflight`. Doing so would force the transfer mechanics into
 * the host. Given the size of data frequently involved, and the myriad
 * of potential transfer technologies, it was deemed leaving this up to
 * the manager was a more flexible solution.
 *
 * In summary, for a manager capable of determining the location for
 * data, a host won't call `preflight` if it can't honor the
 * specified location.
 *
 *
 * @section publish publish
 *
 * 'Publish' is an ambiguous term, if ever there was one. It seems to
 * mean so many completely different things depending on who you ask. As
 * such, we defined it in this API, and documentation, as the process
 * of creating a new asset in an @ref asset_management_system, or
 * updating an existing one - which usually means a new version should
 * be created.
 *
 * The canonical publishing process for new data from a @ref host
 * requires it to:
 *
 * - Check whether the @ref manager is interested in that particular
 *   @ref entity "entity's" @ref trait "traits", via the manager's
 *   @fqref{hostApi.Manager.managementPolicy} "managementPolicy", and
 *   what traits it is capable of persisting property data for.
 * - Call @ref preflight to allow any prerequisite housekeeping
 *   to be performed, and a working @ref entity_reference returned.
 * - Resolve the working reference to determine the URL for new data to
 *   be written to.
 * - Write the data accordingly.
 * - Call @ref register to finalize the publish and confirm to the
 *   manager that the data has been written.
 *
 * @note Some managers may not be able to determine trait properties in
 * advance, and act more as librarians. This is indicated in the
 * returned management policy. Hosts must act according to this.
 *
 * When publishing existing data, the preflight step is omitted.
 *
 *
 * @section register register
 *
 * The registration mechanism allows for a @ref host to create or update
 * an @ref entity. This is the sole mechanism by which data can be
 * mutated within the system.
 *
 * It is up to the @ref manager to decide what the registration of new
 * data to an existing entity should mean. The API has no opinion as to
 * whether it is permitted to update in-place, or to require the
 * creation of a new version. The manager should apply its own rules,
 * and return an @ref entity_reference that points to the result of the
 * registration - whether this be a new version, or the same entity that
 * was subject to the registration.
 *
 * For compound entities, the registration call signifies the completion
 * of the registration of any child entities.
 *
 *
 * @section resolve resolve
 *
 * 'Resolving' an @ref entity_reference is the process of turning it
 * back into the data for one or more @ref trait "traits". Resolution is
 * usually performed just-in-time. This is the fundamental mechanism
 * that makes documents portable, and where OpenAssetIO (and other
 * resolution systems) bring their value - the @ref manager
 * backing the resolution process is free to use any contextual
 * information to vary the result of the resolution such that it is as
 * correct/appropriate as it can be for the current resolution @ref
 * Context.
 *
 * @section Specification Specification
 *
 * Within OpenAssetIO, it is often required to describe the 'type' of
 * something. This could be some data a @ref host wishes to query or
 * @ref publish, or the nature of a relationship between two assets.
 * OpenAssetIO uses a @ref trait "traits" based system, where each
 * distinct characteristic is combined to form a @ref trait_set.
 *
 * Specifications define well-known sets of traits to ensure they are
 * consistently used by a host and/or manager when populating or
 * retrieving data.
 *
 * The specification classes provide runtime and/or compile time checks
 * to help avoid programming errors.
 *
 *
 * @section trait Trait
 *
 * Traits define concrete aspects of the nature of something. They
 * are combined in a @ref trait_set to form a precise description of
 * something.
 *
 * Trait sets are used to categorize @ref entity "entities", their
 * relationships or the characteristics of a @ref host process through
 * the @ref Context "context's" @ref locale.
 *
 * A trait may optionally define one or more properties that hold
 * simple-typed values.
 *
 * When an entity is @ref publish "published" or @ref resolve "resolved"
 * through the API, these trait properties are used to hold the entity's
 * data.
 *
 * @see @ref entities_traits_and_specifications
 *
 *
 * @section trait_set Trait Set
 *
 * A trait set is the logical conjunction of one or more @ref trait
 * "traits". They are the basis of the classifications system used in
 * OpenAssetIO. Sets of traits are additive when used to classify
 * something - meaning that the thing in question has all of the traits
 * in the set.
 *
 * Trait sets are supplied to the @ref manager through the API whenever
 * there is need to describe the type of something in advance. A good
 * example of their usage is in the
 * @fqref{hostApi.Manager.managementPolicy} "managementPolicy" query,
 * where the manager declares its intent towards specific types of
 * entity - described by the supplied trait sets, and which of those
 * traits it is capable of storing or recalling property data for.
 *
 * @see @ref entities_traits_and_specifications
 */
