/*!
 * @page glossary Glossary
 *
 * @section action_group Action Group
 *
 * Within the transaction model used by this API, on the host side,
 * multiple Action Groups can be pushed onto a 'stack'. This greatly
 * simplifies the handling of transactions within a @ref host.
 *
 * Each group represents a logical action. If this is a compound action
 * that re-uses several atomic actions, each of these may be represented
 * by their own Action Group on the stack. For example, publishing a
 * texture may be a single action group, publishing all textures could
 * simply re-use this function many times, wrapping the whole thing in
 * enclosing action group.
 *
 * The @ref openassetio.hostAPI.transactions.TransactionCoordinator
 * "TransactionCoordinator" class takes care of starting, ending or
 * cancelling a @ref transaction through the @ref ManagerInterface as
 * groups are pushed/popped from the action group stack. This means that
 * the implementation of the ManagerInterface doesn't have to concern
 * itself with the complexities of managing a stack.
 *
 *
 * @section asset_management_system Asset Management System
 *
 * Responsible for managing @ref entity "Entities", in some structured
 * fashion.  Often based around some kind of a database. Many asset
 * management systems allow entities to be 'versioned', or related to
 * each other.  The primary goal being make collaborative working
 * easier, and to allow the history of work to be tracked. Very similar
 * to source control within a software development environment.
 *
 * @section Context Context
 *
 * A Context is an object that holds all of the persistent state between
 * a set of connected calls to the API. Its properties define details of
 * how a @ref host is calling the Asset API. In addition to information
 * about the desired access (read/write) and persistence of data, the
 * context may contain a @ref
 * openassetio.specifications.LocaleSpecification to better define which
 * part of the users workflow the call is being generated by.
 *
 * The information in the context is vital to interpreting the intent of
 * a @ref host "hosts" actions. For example, if an Image @ref
 * Specification is passed to a browser, a context access of 'kWrite'
 * indicates the host wishes browse for a destination to publish a
 * single image @ref entity to, so any viable container should be
 * selectable. If it is 'kRead' then the host is wishing to browse for
 * an entity to read, so only existing entities that match the
 * specification should be presented. If 'kWriteMultiple' is specified,
 * then the applicable selections generally changes again.
 *
 * The Context also holds an opaque (to the host) data pointer, created
 * by the @ref ManagerInterface, that contains any persistent state its
 * implementation wishes to store.
 *
 * @see @ref openassetio.Context "Context"
 *
 * @section entity entity
 *
 * An 'entity' is the generic name for something that is managed by a
 * @ref asset_management_system. Entities are identified by an @ref
 * entity_reference. We choose the term 'entity' as some systems
 * give a specific meaning to an 'asset', such that all assets are
 * entities, but not all entities are assets.
 *
 * As a simplified example, an 'asset' may always require to exist in
 * some organizational hierarchy, and be the only thing that can be
 * version managed. An entity however, can refer to anything that the
 * Asset Management System knows about, including a part of the
 * organizational hierarchy, or a specific version or component part of
 * an 'asset'.
 *
 * In the core API there are only three properties needed to represent
 * any possible entity:
 *
 * @li name
 * @li @ref primary_string
 * @li @ref attributes
 *
 * This makes it relatively straightforward for an @ref
 * asset_management_system to provide support for any entity that a @ref
 * host may wish to store, by simply storing and retrieving these three
 * properties from its persistent store. If it wishes, or understands
 * specific entity specifications, it can always provide more
 * sophisticated mappings to its own internal types, to provide a better
 * user experience.
 *
 * @section entity_reference Entity Reference
 *
 * An 'entity reference' is the currency of the core API layer. It is
 * used to identify an @ref entity within an @ref asset_management_system
 * and is defined as follows:
 *
 * > A <a href="http://en.wikipedia.org/wiki/Uniform_resource_identifier"
 * > target="_blank">Uniform Resource Identifier</a> that points to a single,
 * > discreet @ref entity in an @ref asset_management_system. If the entity
 * > identified by the reference exists as a child in a hierarchy, then the
 * > entity reference must identify a specific path to that entity, so that
 * > it has a single immediate parent.
 *
 * It is deliberately **not** referred to as an 'id', and should not be
 * thought of as being analogous to a primary key in a database of
 * entities, for various reasons detailed below.
 *
 * An entity reference can be any string, and there are no constraints
 * on the content of the reference other than that of a std::string.
 * It's worth noting however, that if no custom UI widgets are supplied
 * by a manager, a @ref host will simply display it as a standard
 * string. It is up to the design of the @ref manager to decide on the
 * format for it's entity references, and whether they are in a human
 * readable form.
 *
 * > Note: We strongly recommend using a human-readable form that
 * > follows <a href=https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#cite_ref-FOOTNOTERFC_3986,_section_32005_23-0" target="_blank">RFC_3986</a>.
 *
 * The following are examples of perfectly valid entity references:
 *
 *  @li `myasset://DVR/ep01/build/prop/table?v=6&t=model&f=alembic`
 *  @li `e1d2e41c-9594-11e2-9619-f23c91ae2917`
 *  @li <tt>{'job':'DVR', 'path':['ep01','build','prop','table'], 'version':'6', 'type':'model', 'format':'alembic'}</tt>
 *
 * Each of them have their relative merits in different situations, and
 * <b>it is no concern of this set of APIs which one is used</b>. There
 * are only three requirements of the format, and the way it is
 * interpreted by the @ref ManagerInterface "ManagerInterface":
 *
 * 1. Discoverability
 * ------------------
 * It is essential that any given string can be readily identified
 * identified as being an entity reference or not. The @ref
 * openassetio.managerAPI.ManagerInterface.ManagerInterface.isEntityReference
 * "isEntityReference" method will be called frequently by a @ref host
 * to determine if the arbitrary user input is a reference to a managed
 * entity.
 *
 * 2. Uniform Resource Location
 * ----------------------------
 * In an @ref asset_management_system that permits an entity to only exists
 * in a single place within its hierarchy, the subtle differences between a
 * <a href="http://en.wikipedia.org/wiki/Uniform_resource_locator"
 * target="_blank">URL</a> and a <a
 * href="http://en.wikipedia.org/wiki/Uniform_resource_name"
 * target="_blank">URN</a> (both being URIs) may not be relevant. Both a
 * 'UUID' style reference such as `"e1d2e41c-9594-11e2-9619-f23c91ae2917"`
 * and an URL such as
 * `"myasset://DVR/ep01/build/prop/table?v=1&t=model&f=alembic"` may both
 * resolve to the same entity.
 *
 * However, if the @ref asset_management_system allows an entity to be
 * 'aliased' within the system (perhaps analogous to a symbolic link in
 * a POSIX file system), then the UUID approach may no longer comply
 * with the 'single immediate parent' constraint of the original
 * entity reference definition. For example, if the same underlying
 * Entity UUID was available through the following paths:
 *
 *  @li `myasset://DVR/ep01/build/prop/table?v=6...`
 *  @li `myasset://library/furniture/table?v=2...`
 *  @li `myasset://TTL/library/prop/cottageTabl?v=1...`
 *
 * The entity reference passed through this API must always uniquely
 * locate the entity via a specific path, such that relationship queries
 * produce the expected results.
 *
 * In such a system, the ManagerInterface may provide access to
 * alternate paths from any one of these path-specific references via
 * the @ref openassetio.managerAPI.ManagerInterface.ManagerInterface.getRelatedReferences
 * "getRelatedReferences" method, with a suitable @ref Specification.
 *
 * 3. 'Potential' entity representation
 * ------------------------------------
 * It is required within the architecture of this API, to potentially
 * derive an entity reference for new entity **before** it has been
 * created.
 *
 * For example, a 'Save As...' dialog will need to return an entity
 * reference that can be passed to @ref openassetio.hostAPI.Manager.Manager.register().
 *
 * This does not preclude the use of UUID-style references in some cases
 * if desired, it simply means that the Manager may need to support
 * *multiple* formats for an entity reference. Again, this is entirely
 * up to the manager to decide how it wishes to handle future entities.
 *
 *
 * @section host host
 *
 * A 'host' represents some application or tool that would like to
 * interact with an @ref asset_management_system. This is usually a
 * user-facing Digital Content Creation application or a pipeline
 * tool or script.
 *
 * The purpose of OpenAssetIO is to standardize the interaction between a host
 * and an @ref asset_management_system in order to persis or query data.
 * A host communicates with a @ref manager via the @ref openassetio.hostAPI.Manager.Manager class.
 *
 * > Note: The Manager class is an abstraction, that takes care of
 * > sundry housekeeping and helps manage session state. Internally it
 * > holds an instance of the @ref openassetio.managerAPI.ManagerInterface.ManagerInterface
 * > "ManagerInterface" implementation supplied by the @ref
 * > asset_management_system.
 *
 * The host itself is made available to a @ref manager "manager's" @ref
 * ManagerInterface via the @ref
 * openassetio.managerAPI.HostSession "HostSession" supplied to each API
 * call. This allows the manager to adapt its behavior accordingly (if
 * required), and perform any additional actions it may wish to as part
 * of @ref publish "publishing".
 *
 * @section HostInterface
 *
 * The @ref openassetio.hostAPI.HostInterface.HostInterface
 * "HostInterface" class is the abstract interface that any @ref host
 * must implement in order to initialize the API. It will usually
 * contain logic to map native features of the host into the
 * well-known terms defined by this API.
 *
 * The HostInterface is never used directly by a @ref manager, and is
 * instead accessed through the @ref openassetio.managerAPI.Host
 * abstraction, provided by the @ref openassetio.managerAPI.HostSession
 * passed to the manager's implementation. This allows assorted
 * house-keeping and auditing to be performed by the API middleware.
 *
 *
 * @section locale locale
 *
 * Within OpenAssetIO, the term "locale" is used to define which part of a
 * @ref host "host's" implementation is making a particular call to the API.
 * A suitably configured @ref openassetio.specifications.LocaleSpecification
 * "LocaleSpecification", is supplied through the @ref openassetio.Context.Context.locale
 * "locale" property of the @ref openassetio.Context.Context, which is
 * in turn supplied to most @ref ManagerInterface method calls.
 *
 * The locale may be used by a manager to customize its behavior if
 * desired. The locale may contain references to specific objects in the
 * host's native SDK that can be used to determine more information
 * about the origin of the API request.
 *
 * A common use of the locale by a manager is to obtain further
 * information about the originating document during a publish.
 *
 *
 * @section ManagerInterface
 *
 * The @ref openassetio.managerAPI.ManagerInterface.ManagerInterface
 * "ManagerInterface" class is the abstract interface that any @ref
 * asset_management_system must implement in order to be used by the
 * API. It will usually contain appropriate logic to map native features
 * of the asset manager into the well-known terms defined by this API.
 *
 * The ManagerInterface is never used directly by a @ref host, and is
 * instead accessed through the @ref openassetio.hostAPI.Manager
 * abstraction. This allows assorted house-keeping and state management
 * to be performed by the API middleware.
 *
 *
 * @section ManagerPlugin Manager Plugin
 *
 * The Plug-in mechanism implemented by the @ref
 * openassetio.pluginSystem automatically discovers packages that
 * provide an instance of the openassetio.pluginSystem.ManagerPlugin
 * using a search-path based mechanism. This is independent of
 * $PYTHONPATH, and presently searches using the environment variable
 * @ref plugin_path_var
 *
 * The ManagerPlugin instance is then responsible for constructing an
 * instance of the respective @ref asset_management_system's
 * implementation of the @ref openassetio.managerAPI.ManagerInterface
 * "ManagerInterface".
 *
 *
 * @section plugin_path_var $OPENASSETIO_PLUGIN_PATH
 *
 * This is the environment variable used to discover @ref ManagerPlugin
 * "ManagerPlugins", it is searched left-to-right, using standard
 * `$PATH` semantics (delimited by `:` on POSIX systems and
 * `;` on Windows). The first package that registers a specific
 * identifier wins.
 *
 * So to override a plug-in with a dev version, ensure it is to the left
 * of the standard plug-in.
 *
 *
 * @section manager_state Manager State
 *
 * The @ref ManagerInterface is, by design, a stateless, re-entrant API.
 * Consequently, the result of any call to an instance of this class
 * should solely depend on the methods arguments. In real-world use
 * however, it is often required to understand that a series of discreet
 * calls to the API may be part of the same logical user action.
 *
 * The most common (and extreme) example of this is a distributed
 * render. Where multiple processes, spread across multiple hosts are
 * all part of the same 'task'. Many asset systems support the concept
 * of @ref meta_version "meta-versions" (eg: "vLatest"). Providing
 * stable resolution of these is essential to deterministic renders.
 *
 * A far simpler example of associating API calls is to provide caching
 * relative to the lifetime of a specific action.
 *
 * OpenAssetIO provides a mechanism to support the entire range of use cases
 * for 'session state' whilst keeping the interface itself stateless.
 *
 * This is achieved by allowing the manager to inject state into each
 * @ref Context created by the @ref host. The host guarantees to
 * manage the lifetime of their contexts appropriately, and re-use the
 * same context for logically related API calls. The result of this is
 * that the manager can use injected state object to form a persistent
 * anchor across distributed calls.
 *
 * The manager's state object is opaque to the host.
 *
 *   @see @ref openassetio.managerAPI.ManagerInterface.ManagerInterface.createState "ManagerInterface.createState"
 *   @see @ref openassetio.managerAPI.ManagerInterface.ManagerInterface.freezeState "ManagerInterface.freezeState"
 *   @see @ref openassetio.managerAPI.ManagerInterface.ManagerInterface.thawState "ManagerInterface.thawState"
 *
 *
 * @section attributes Attributes
 *
 * Within the core API, Attributes are used to persist additional
 * properties of an @ref entity. This is particularly useful when there
 * is no meaningful @ref primary_string for any given type of entity.
 *
 * The @ref manager must guarantee to store and recall any attributes set
 * by the @ref host. They may freely re-map any attribute names to their
 * local names internally, as long as the mapping is reversed for
 * queries.
 *
 * Attributes names are strings, and their values are simple **plain
 * old data** types (ie. int, float, string, bool).
 *
 * > Note: The length of a value is yet to be defined, but ideally it
 * > will be something suitably large - this will only be restricted if
 * > common host applications and/or managers have recurring practical
 * > limits.
 *
 * A simple example of where entity attributes bring great value is
 * something as humble as an ImageSpecification entity that resolves to
 * an image sequence.
 *  - When a host wishes to read the sequence, if the entity has a
 *  colorspace attribute then it can ensure the data is correctly
 *  interpreted, without relying on fragile mechanisms such as the file
 *  extension.
 *  - When a host wishes to write image data, the entity's file format
 *  attribute (along with any associated encoding options) can be used
 *  to ensure the data is reliably written with the correct format,
 *  bit-depth and compression, etc.
 *
 * Shots are another type of entity that makes use of this mechanism. As
 * there is no real meaningful @ref primary_string, all relevant data
 * about its frame range, handles, etc. are persisted via the entity's
 * attributes.
 *
 * The @ref Specification of any given entity is used to determine the
 * applicable specific set of well-known OpenAssetIO attribute names.
 *
 *
 * @section meta_version Meta-version
 *
 * It is common for am @ref asset_management_system to allow an @ref entity
 * version managed. Some systems also allow the concept of what we call a
 * 'meta-version'. For example "latest" or "latestApprovedForLighting".  These
 * are version strings that need to be further resolved using @ref
 * openassetio.hostAPI.Manager.Manager.finalizedEntityVersion
 * "finalizedEntityVersion()" before they can be assumed to be
 * pointing to a specific 'concrete' version of an entity.
 *
 * Stable resolution of meta-versions over time, or across a
 * distributed task is achieved via the @ref manager_state mechanism.
 *
 *
 * @section manager manager
 *
 * A 'manager' represents some @ref asset_management_system that forms
 * a source of truth for some number of entities. They usually consist
 * of some centralized database that tracks assets - known here as @ref
 * entity "entities", managing their versions and relationships.
 *
 * The purpose of OpenAssetIO is to standardize the interactions between a @ref
 * host and one of these systems in order to query or persist data.
 *
 * Asset managers will generally re-map the well-known OpenAssetIO
 * concepts (@ref Specification, @ref attributes) into their own
 * internal structures, and back again when queried.
 *
 * Managers are made available via a @ref ManagerPlugin, that ultimately
 * registers classes derived from the @ref ManagerInterface.
 *
 * A @ref host never uses the ManagerInterface class directly, but instead
 * uses the @ref openassetio.hostAPI.Manager "Manager" class. This
 * indirection allows sundry house keeping and state management.
 *
 *
 * @section preflight preflight
 *
 * @ref asset_management_system "Asset management systems" are roughly
 * divided into two camps - those that can tell a @ref host in advance
 * the location at which data should be created, and those that simply
 * track data at its existing location. A @ref manager implementation
 * declares its behavior to the host via the @ref
 * openassetio.hostAPI.Manager.Manager.managementPolicy
 * "managementPolicy" method.
 *
 * If a manager has said it is capable of defining the location for
 * future data ahead of time, the host must call the @ref
 * openassetio.hostAPI.Manager.Manager.preflight "preflight" method and
 * resolve the returned @ref entity_reference to determine the manager's
 * chosen location for the data and use this for any write operations.
 *
 * The `preflight` method is also allowed to change the entity
 * reference as required. This mechanism serves several purposes:
 *
 * - It allows the manager to dictate if an existing target entity is
 *   mutable. It can return an updated entity reference if the
 *   original entity should be left untouched (ie. creating a new
 *   version).
 * - It allows the manager to allocate a placeholder version for a
 *   reference containing a @ref meta_version "meta-version".
 * - If appropriate, it can avoid the need to retrospectively copy data
 *   to its intended destination immediately after creation.
 *
 * There are two scenarios where `preflight` will not be called:
 *
 * - When the manager has declared that it is not capable of providing
 *   the location for future data in advance (via managementPolicy).
 * - When the data already exists at some target location, such as when
 *   assetizing an existing file.
 *
 * In these situations, only @ref register will be called by the host.
 * In the first situation, calling `preflight` would be pointless
 * as the manager has no way to provide a meaningful answer.
 *
 * In the second situation it removes the responsibility for the host to
 * transfer the data from its current location to that specified by
 * `preflight`. Doing so would force the transfer mechanics into
 * the host. Given the size of data frequently involved, and the myriad
 * of potential transfer technologies, it was deemed leaving this up to
 * the manager was a more flexible solution.
 *
 * In summary, for a manager capable of determining the location for
 * data, a host won't call `preflight` if it can't honor the
 * specified location.
 *
 *
 * @section publish publish
 *
 * 'Publish' is an ambiguous term, if ever there was one. It seems to
 * mean so many completely different things depending on who you ask. As
 * such, we defined it in this API, and documentation, as the process
 * of creating a new asset in an @ref asset_management_system, or
 * updating an existing one - which usually means a new version should
 * be created.
 *
 * The canonical publishing process for new data from a @ref host
 * requires it to:
 *
 * - Check whether the @ref manager is interested in that particular
 *   @ref Specification of @ref entity, via the manager's @ref openassetio.hostAPI.Manager.Manager.managementPolicy
 *   "managementPolicy".
 * - Call @ref preflight to allow any prerequisite housekeeping
 *   to be performed, and a working @ref entity_reference returned.
 * - Resolve the working reference to determine the URL for new data to
 *   be written to.
 * - Write the data accordingly.
 * - Call @ref register to finalize the publish and confirm to the
 *   manager that the data has been written.
 *
 * @note Some managers may not be able to determine the path for data to
 * be written to, and act more as librarians. This is indicated in the
 * returned management policy. Hosts must act according to this.
 *
 * When publishing existing data, the preflight step is omitted.
 *
 *
 * @section register register
 *
 * The registration mechanism allows for a @ref host to create or update
 * an @ref entity. This is the sole mechanism by which data can be
 * mutated within the system.
 *
 * It is up to the @ref manager to decide what the registration of new
 * data to an existing entity should mean. The API has no opinion as to
 * whether it is permitted to update in-place, or to require the
 * creation of a new version. The manager should apply its own rules,
 * and return an @ref entity_reference that points to the result of the
 * registration - whether this be a new version, or the same entity that
 * was subject to the registration.
 *
 * For compound entities, the registration call signifies the completion
 * of the registration of any child entities.
 *
 *
 * @section resolve resolve
 *
 * 'Resolving' an @ref entity_reference is the process of turning it
 * back into the entity's @ref primary_string. Resolution is usually
 * performed just-in-time. This is the fundamental mechanism that makes
 * documents portable, and where OpenAssetIO (and other resolution
 * systems) bring their value - the @ref manager backing the resolution
 * process is free to use any contextual information to vary the result
 * of the resolution such that it is as correct/appropriate as it can be
 * for the current resolution @ref Context.
 *
 * @section primary_string Primary String
 *
 * If this API was to do just one thing, it would be to turn an @ref
 * entity_reference into some other string - the thing a @ref host would
 * have used as currency without the API (see @ref resolve
 * "resolution"). More often than not, this is a file path, but it
 * could be anything.
 *
 * This string is called the 'primary string'. It is passed to @ref
 * openassetio.managerAPI.ManagerInterface.ManagerInterface.register
 * "ManagerInterface.register" when an entity is created or updated and
 * should be persisted by the @ref manager by the most appropriate means.
 * * Generally speaking there are two types of primary string:
 *  - URLs that point to data
 *  - Some other arbitray string
 *
 * The fundamental rule is that the Manager must round-trip this string
 * intact through @ref openassetio.hostAPI.Manager.Manager.register
 * "register" and @ref openassetio.hostAPI.Manager.Manager.resolveEntityReference
 * "resolveEntityReference". There is an exception to this rule though. When
 * the string is an URL, the manager is free to modify the URL (eg. by
 * re-locating files) as long as the result of @ref resolve
 * "resolving" the reference at some later date, in some other context,
 * points to the same underlying data.
 *
 * This singular opportunity forms one of the core benefits of JIT
 * resolution. Documents can be made portable, if the @ref manager can
 * resolve a reference to the best location for any given entities data
 * based on the current context.
 *
 * @section session session
 *
 * OpenAssetIO is instantiated by a @ref host in order to talk to one or
 * more @ref asset_management_system "asset management systems". To do
 * so, the host creates a new @ref openassetio.hostAPI.Session "Session"
 * for each manager it wishes to communicate with. The Session object is
 * responsible for managing the lifetime of a @ref manager and provides
 * mechanisms for creating a @ref Context and persisting details of
 * which manager is currently in use.
 *
 *
 * @section Specification Specification
 *
 * Within this API, it is often required to describe the 'type' of
 * something. This could be some data a @ref host wishes to query or @ref publish,
 * or the nature of a relationship between two assets. OpenAssetIO
 * provides a rich, hierarchical classification mechanism through the
 * @ref openassetio.Specification system.
 *
 * Specifications are key to allowing an arbitrary @ref host to
 * talk to an arbitrary @ref manager. Specifications serve as a filter.
 * OpenAssetIO provides well-known specifications for common asset
 * types. This allows a @ref manager to provide generic support for a
 * given entity specification, without needing to know anything about
 * the @ref host that is producing or consuming it. Conversely, a @ref host
 * can query a well-known specification without having to know the
 * @ref manager "manager's" native terminology.
 *
 * At hear, specifications are simply a set of key-value pairs, with an
 * additional 'schema' - a string that can be used to convey what keys
 * to expect to be present. The schema is hierarchical. For example the
 * schema `core.entity:file.image` states that it is a
 * `core.entity` of type `file.image`.  It can be inferred
 * that this should have all the properties of a `file`, but will
 * have additional specialized properties only associated with a
 * `file.image`.
 *
 * This approach allows any new Specification to be supported in a generic
 * fashion by simply saving/recalling the key/value pairs.
 * Specification schemas can also be decomposed hierarchically to allow
 * more general type-specific functionality to be automatically applied
 * to any more specialized derivations.
 *
 * Factory methods are provided, that use the schema to automatically
 * wrap higher-level objects to around the key-value pairs, to give a
 * more object-orientated development pattern with concrete accessors if
 * desired.
 *
 * The best way to think of a Specification in general use is simply as
 * a glorified 'type string'. The fact that is also can contain
 * key-value pairs is in some ways irrelevant to understanding its
 * main purpose. A Manager guarantees to be able to 'filter' Entities
 * based on a Specification, and a Host always Registers a new Entity by
 * identifying it with a Specification.
 *
 * Any key-value information associated with a specification passed to
 * an API call should be considered a 'hint' rather than required or
 * storable information.
 *
 *  @see @ref openassetio.specifications "specifications"
 *
 *
 * @section transaction Transaction
 *
 * See the @ref transactions page for a full description of the
 * transactional model used in this API. In brief, The @ref manager_state
 * is used to help a @ref manager connect multiple calls to the API.
 * Often this is to allow a series of actions to be undone, or to ensure
 * that queries spread over time, produce coherent results.
 */
